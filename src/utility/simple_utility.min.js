// Build: "deno bundle https://deno.land/x/simple_utility@v0.0.7/mod.compatible.ts | esbuild --minify | head -c -1"
function E(t){return btoa([...t].map(r=>String.fromCharCode(r)).join(""))}function x(t){return new Uint8Array([...atob(t)].map(r=>r.charCodeAt(0)))}export{E as base64Encode};export{x as base64Decode};const i="P-384",d="SHA-384";async function f(t){const r={name:"ECDH",namedCurve:i},e={name:"AES-GCM",length:32*8},n=await crypto.subtle.importKey("spki",t.publicKey,r,!1,[]),a=await crypto.subtle.importKey("pkcs8",t.privateKey,r,!1,["deriveKey","deriveBits"]),s={name:"ECDH",public:n};return await crypto.subtle.deriveKey(s,a,e,!1,["encrypt","decrypt"])}async function y(t,r){const e=t?"SHA-512":"SHA-256";return new Uint8Array(await crypto.subtle.digest(e,r))}async function D(t){const r=t?["deriveKey","deriveBits"]:["sign","verify"],e={name:t?"ECDH":"ECDSA",namedCurve:i},{publicKey:n,privateKey:a}=await crypto.subtle.generateKey(e,!0,r);return{publicKey:new Uint8Array(await crypto.subtle.exportKey("spki",n)),privateKey:new Uint8Array(await crypto.subtle.exportKey("pkcs8",a))}}async function K(t,r){const e={name:"AES-GCM",tagLength:128,iv:crypto.getRandomValues(new Uint8Array(12))},n=await f(t),a=new Uint8Array(16+12+r.byteLength);return a.set(e.iv,0),a.set(new Uint8Array(await crypto.subtle.encrypt(e,n,r)),e.iv.byteLength),a}async function A(t,r){const e={name:"AES-GCM",tagLength:128,iv:r.subarray(0,12)},n=await f(t);return new Uint8Array(await crypto.subtle.decrypt(e,n,r.subarray(12)))}async function v(t,r){const e={name:"ECDSA",namedCurve:i},n={name:"ECDSA",hash:{name:d}},a=await crypto.subtle.importKey("pkcs8",t,e,!1,["sign"]);return new Uint8Array(await crypto.subtle.sign(n,a,r))}async function S(t,r,e){const n={name:"ECDSA",namedCurve:i},a={name:"ECDSA",hash:{name:d}},s=await crypto.subtle.importKey("spki",r,n,!1,["verify"]);return await crypto.subtle.verify(a,s,t,e)}export{y as cryptoHash};export{D as cryptoGenerateKey};export{K as cryptoEncrypt};export{A as cryptoDecrypt};export{v as cryptoSign};export{S as cryptoVerify};function w(t){return Math.floor((t??new Date).getTime()/1e3)}function C(t){return new Date(t*1e3)}function U(t){const[r,e,n,a,s,c]=t.split(/[/ :TZ_.-]/i).map(o=>Number(o));return w(new Date(r,(e??1)-1,n??1,a??0,s??0,c??0))}export{w as dateEncode};export{C as dateDecode};export{U as dateParse};async function l(t,r){return new Uint8Array(await new Response(new Blob([t]).stream().pipeThrough(r)).arrayBuffer())}async function k(t){return await l(t,new CompressionStream("deflate-raw"))}async function L(t){return await l(t,new DecompressionStream("deflate-raw"))}export{k as deflateEncode};export{L as deflateDecode};async function H(t,r,e){const{origin:n,pathname:a}=/^http(s|):\/\//i.test(t)?new URL(t):new URL(t,location.href),s=new URLSearchParams(e?.query).toString(),c=await fetch(`${n}${a}${s&&"?"}${s}`,{method:e?.method??"GET",credentials:e?.credentials??"omit",mode:e?.mode??"cors",cache:e?.cache??"no-cache",redirect:e?.redirect??"follow",keepalive:e?.keepalive??!1,referrerPolicy:e?.referrerPolicy??"no-referrer",referrer:e?.referrer??"",integrity:e?.integrity??"",signal:e?.signal??null,headers:e?.headers??{},body:e?.body??null,window:null});switch(r){case"text":return await c.text();case"json":return await c.json();case"form":return await c.formData();case"byte":return new Uint8Array(await c.arrayBuffer());case"buffer":return await c.arrayBuffer();case"blob":return await c.blob();case"ok":return c.ok;case"code":return c.status;case"header":return c.headers;case"response":return c;default:throw new Error}}export{H as fetchExtend};function u(t){return new TextEncoder().encode(t)}function m(t){return new TextDecoder().decode(t)}function p(t){return[...t].map(r=>r.toString(16).toUpperCase().padStart(2,"0")).join("")}function B(t){return t.trim().replace(/\r/g,"").replace(/\t/g," ").replace(/ +/g," ").replace(/ +$/mg,"")}export{u as ucEncode};export{m as ucDecode};export{p as hexEncode};export{B as trimExtend};const b=32,h=1,g=4,T=32+1+4;async function V(t){const r=new Uint8Array(t.reduce((n,[a,s])=>n+T+u(a).byteLength+s.byteLength,0));let e=0;for(const[n,a]of t){const s=u(n),c=a;r.set(await y(!1,c),e),e+=b,new DataView(r.buffer,e).setUint8(0,s.byteLength),e+=h,new DataView(r.buffer,e).setUint32(0,c.byteLength),e+=g,r.set(s,e),e+=s.byteLength,r.set(c,e),e+=c.byteLength}return r}async function G(t){const r=[];let e=0;for(;e<t.byteLength;){const n=t.subarray(e,e+=b),a=new DataView(t.buffer,e).getUint8(0);e+=h;const s=new DataView(t.buffer,e).getUint32(0);e+=g;const c=m(t.subarray(e,e+=a)),o=t.subarray(e,e+=s);if(p(n)!==p(await y(!1,o)))throw new Error;r.push([c,o])}return r}export{V as minipackEncode};export{G as minipackDecode};